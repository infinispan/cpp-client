// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bank.proto

#ifndef PROTOBUF_bank_2eproto__INCLUDED
#define PROTOBUF_bank_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace sample_bank_account {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_bank_2eproto();
void protobuf_AssignDesc_bank_2eproto();
void protobuf_ShutdownFile_bank_2eproto();

class User;
class User_Address;
class Account;
class Account_Limits;
class Transaction;
class int_array;
class user_list;

enum User_Gender {
  User_Gender_MALE = 0,
  User_Gender_FEMALE = 1
};
bool User_Gender_IsValid(int value);
const User_Gender User_Gender_Gender_MIN = User_Gender_MALE;
const User_Gender User_Gender_Gender_MAX = User_Gender_FEMALE;
const int User_Gender_Gender_ARRAYSIZE = User_Gender_Gender_MAX + 1;

const ::google::protobuf::EnumDescriptor* User_Gender_descriptor();
inline const ::std::string& User_Gender_Name(User_Gender value) {
  return ::google::protobuf::internal::NameOfEnum(
    User_Gender_descriptor(), value);
}
inline bool User_Gender_Parse(
    const ::std::string& name, User_Gender* value) {
  return ::google::protobuf::internal::ParseNamedEnum<User_Gender>(
    User_Gender_descriptor(), name, value);
}
// ===================================================================

class User_Address : public ::google::protobuf::Message {
 public:
  User_Address();
  virtual ~User_Address();

  User_Address(const User_Address& from);

  inline User_Address& operator=(const User_Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User_Address& default_instance();

  void Swap(User_Address* other);

  // implements Message ----------------------------------------------

  User_Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User_Address& from);
  void MergeFrom(const User_Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string street = 1;
  inline bool has_street() const;
  inline void clear_street();
  static const int kStreetFieldNumber = 1;
  inline const ::std::string& street() const;
  inline void set_street(const ::std::string& value);
  inline void set_street(const char* value);
  inline void set_street(const char* value, size_t size);
  inline ::std::string* mutable_street();
  inline ::std::string* release_street();
  inline void set_allocated_street(::std::string* street);

  // required string postCode = 2;
  inline bool has_postcode() const;
  inline void clear_postcode();
  static const int kPostCodeFieldNumber = 2;
  inline const ::std::string& postcode() const;
  inline void set_postcode(const ::std::string& value);
  inline void set_postcode(const char* value);
  inline void set_postcode(const char* value, size_t size);
  inline ::std::string* mutable_postcode();
  inline ::std::string* release_postcode();
  inline void set_allocated_postcode(::std::string* postcode);

  // required int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sample_bank_account.User.Address)
 private:
  inline void set_has_street();
  inline void clear_has_street();
  inline void set_has_postcode();
  inline void clear_has_postcode();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* street_;
  ::std::string* postcode_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static User_Address* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  void Swap(User* other);

  // implements Message ----------------------------------------------

  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef User_Address Address;

  typedef User_Gender Gender;
  static const Gender MALE = User_Gender_MALE;
  static const Gender FEMALE = User_Gender_FEMALE;
  static inline bool Gender_IsValid(int value) {
    return User_Gender_IsValid(value);
  }
  static const Gender Gender_MIN =
    User_Gender_Gender_MIN;
  static const Gender Gender_MAX =
    User_Gender_Gender_MAX;
  static const int Gender_ARRAYSIZE =
    User_Gender_Gender_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Gender_descriptor() {
    return User_Gender_descriptor();
  }
  static inline const ::std::string& Gender_Name(Gender value) {
    return User_Gender_Name(value);
  }
  static inline bool Gender_Parse(const ::std::string& name,
      Gender* value) {
    return User_Gender_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated int32 accountIds = 2;
  inline int accountids_size() const;
  inline void clear_accountids();
  static const int kAccountIdsFieldNumber = 2;
  inline ::google::protobuf::int32 accountids(int index) const;
  inline void set_accountids(int index, ::google::protobuf::int32 value);
  inline void add_accountids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      accountids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_accountids();

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string surname = 4;
  inline bool has_surname() const;
  inline void clear_surname();
  static const int kSurnameFieldNumber = 4;
  inline const ::std::string& surname() const;
  inline void set_surname(const ::std::string& value);
  inline void set_surname(const char* value);
  inline void set_surname(const char* value, size_t size);
  inline ::std::string* mutable_surname();
  inline ::std::string* release_surname();
  inline void set_allocated_surname(::std::string* surname);

  // repeated .sample_bank_account.User.Address addresses = 5;
  inline int addresses_size() const;
  inline void clear_addresses();
  static const int kAddressesFieldNumber = 5;
  inline const ::sample_bank_account::User_Address& addresses(int index) const;
  inline ::sample_bank_account::User_Address* mutable_addresses(int index);
  inline ::sample_bank_account::User_Address* add_addresses();
  inline const ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User_Address >&
      addresses() const;
  inline ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User_Address >*
      mutable_addresses();

  // optional int32 age = 6;
  inline bool has_age() const;
  inline void clear_age();
  static const int kAgeFieldNumber = 6;
  inline ::google::protobuf::int32 age() const;
  inline void set_age(::google::protobuf::int32 value);

  // optional .sample_bank_account.User.Gender gender = 7;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 7;
  inline ::sample_bank_account::User_Gender gender() const;
  inline void set_gender(::sample_bank_account::User_Gender value);

  // optional string notes = 8;
  inline bool has_notes() const;
  inline void clear_notes();
  static const int kNotesFieldNumber = 8;
  inline const ::std::string& notes() const;
  inline void set_notes(const ::std::string& value);
  inline void set_notes(const char* value);
  inline void set_notes(const char* value, size_t size);
  inline ::std::string* mutable_notes();
  inline ::std::string* release_notes();
  inline void set_allocated_notes(::std::string* notes);

  // @@protoc_insertion_point(class_scope:sample_bank_account.User)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_surname();
  inline void clear_has_surname();
  inline void set_has_age();
  inline void clear_has_age();
  inline void set_has_gender();
  inline void clear_has_gender();
  inline void set_has_notes();
  inline void clear_has_notes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > accountids_;
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 age_;
  ::std::string* surname_;
  ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User_Address > addresses_;
  ::std::string* notes_;
  int gender_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class Account_Limits : public ::google::protobuf::Message {
 public:
  Account_Limits();
  virtual ~Account_Limits();

  Account_Limits(const Account_Limits& from);

  inline Account_Limits& operator=(const Account_Limits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account_Limits& default_instance();

  void Swap(Account_Limits* other);

  // implements Message ----------------------------------------------

  Account_Limits* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account_Limits& from);
  void MergeFrom(const Account_Limits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double maxDailyLimit = 1;
  inline bool has_maxdailylimit() const;
  inline void clear_maxdailylimit();
  static const int kMaxDailyLimitFieldNumber = 1;
  inline double maxdailylimit() const;
  inline void set_maxdailylimit(double value);

  // optional double maxTransactionLimit = 2;
  inline bool has_maxtransactionlimit() const;
  inline void clear_maxtransactionlimit();
  static const int kMaxTransactionLimitFieldNumber = 2;
  inline double maxtransactionlimit() const;
  inline void set_maxtransactionlimit(double value);

  // @@protoc_insertion_point(class_scope:sample_bank_account.Account.Limits)
 private:
  inline void set_has_maxdailylimit();
  inline void clear_has_maxdailylimit();
  inline void set_has_maxtransactionlimit();
  inline void clear_has_maxtransactionlimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double maxdailylimit_;
  double maxtransactionlimit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static Account_Limits* default_instance_;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Account_Limits Limits;

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string description = 2 [default = "Checking account"];
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required fixed64 creationDate = 3;
  inline bool has_creationdate() const;
  inline void clear_creationdate();
  static const int kCreationDateFieldNumber = 3;
  inline ::google::protobuf::uint64 creationdate() const;
  inline void set_creationdate(::google::protobuf::uint64 value);

  // optional .sample_bank_account.Account.Limits limits = 4;
  inline bool has_limits() const;
  inline void clear_limits();
  static const int kLimitsFieldNumber = 4;
  inline const ::sample_bank_account::Account_Limits& limits() const;
  inline ::sample_bank_account::Account_Limits* mutable_limits();
  inline ::sample_bank_account::Account_Limits* release_limits();
  inline void set_allocated_limits(::sample_bank_account::Account_Limits* limits);

  // repeated bytes blurb = 5;
  inline int blurb_size() const;
  inline void clear_blurb();
  static const int kBlurbFieldNumber = 5;
  inline const ::std::string& blurb(int index) const;
  inline ::std::string* mutable_blurb(int index);
  inline void set_blurb(int index, const ::std::string& value);
  inline void set_blurb(int index, const char* value);
  inline void set_blurb(int index, const void* value, size_t size);
  inline ::std::string* add_blurb();
  inline void add_blurb(const ::std::string& value);
  inline void add_blurb(const char* value);
  inline void add_blurb(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& blurb() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_blurb();

  // @@protoc_insertion_point(class_scope:sample_bank_account.Account)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_creationdate();
  inline void clear_has_creationdate();
  inline void set_has_limits();
  inline void clear_has_limits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  static ::std::string* _default_description_;
  ::google::protobuf::uint64 creationdate_;
  ::sample_bank_account::Account_Limits* limits_;
  ::google::protobuf::RepeatedPtrField< ::std::string> blurb_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  Transaction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string description = 2;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 2;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required int32 accountId = 3;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIdFieldNumber = 3;
  inline ::google::protobuf::int32 accountid() const;
  inline void set_accountid(::google::protobuf::int32 value);

  // required fixed64 date = 4;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline ::google::protobuf::uint64 date() const;
  inline void set_date(::google::protobuf::uint64 value);

  // required double amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline double amount() const;
  inline void set_amount(double value);

  // required bool isDebit = 6;
  inline bool has_isdebit() const;
  inline void clear_isdebit();
  static const int kIsDebitFieldNumber = 6;
  inline bool isdebit() const;
  inline void set_isdebit(bool value);

  // required bool isValid = 7;
  inline bool has_isvalid() const;
  inline void clear_isvalid();
  static const int kIsValidFieldNumber = 7;
  inline bool isvalid() const;
  inline void set_isvalid(bool value);

  // @@protoc_insertion_point(class_scope:sample_bank_account.Transaction)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_isdebit();
  inline void clear_has_isdebit();
  inline void set_has_isvalid();
  inline void clear_has_isvalid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* description_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 accountid_;
  ::google::protobuf::uint64 date_;
  double amount_;
  bool isdebit_;
  bool isvalid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static Transaction* default_instance_;
};
// -------------------------------------------------------------------

class int_array : public ::google::protobuf::Message {
 public:
  int_array();
  virtual ~int_array();

  int_array(const int_array& from);

  inline int_array& operator=(const int_array& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const int_array& default_instance();

  void Swap(int_array* other);

  // implements Message ----------------------------------------------

  int_array* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const int_array& from);
  void MergeFrom(const int_array& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 theArray = 1;
  inline int thearray_size() const;
  inline void clear_thearray();
  static const int kTheArrayFieldNumber = 1;
  inline ::google::protobuf::int32 thearray(int index) const;
  inline void set_thearray(int index, ::google::protobuf::int32 value);
  inline void add_thearray(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      thearray() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_thearray();

  // @@protoc_insertion_point(class_scope:sample_bank_account.int_array)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > thearray_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static int_array* default_instance_;
};
// -------------------------------------------------------------------

class user_list : public ::google::protobuf::Message {
 public:
  user_list();
  virtual ~user_list();

  user_list(const user_list& from);

  inline user_list& operator=(const user_list& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const user_list& default_instance();

  void Swap(user_list* other);

  // implements Message ----------------------------------------------

  user_list* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const user_list& from);
  void MergeFrom(const user_list& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sample_bank_account.User theList = 1;
  inline int thelist_size() const;
  inline void clear_thelist();
  static const int kTheListFieldNumber = 1;
  inline const ::sample_bank_account::User& thelist(int index) const;
  inline ::sample_bank_account::User* mutable_thelist(int index);
  inline ::sample_bank_account::User* add_thelist();
  inline const ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User >&
      thelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User >*
      mutable_thelist();

  // @@protoc_insertion_point(class_scope:sample_bank_account.user_list)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User > thelist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_bank_2eproto();
  friend void protobuf_AssignDesc_bank_2eproto();
  friend void protobuf_ShutdownFile_bank_2eproto();

  void InitAsDefaultInstance();
  static user_list* default_instance_;
};
// ===================================================================


// ===================================================================

// User_Address

// required string street = 1;
inline bool User_Address::has_street() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User_Address::set_has_street() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User_Address::clear_has_street() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User_Address::clear_street() {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    street_->clear();
  }
  clear_has_street();
}
inline const ::std::string& User_Address::street() const {
  return *street_;
}
inline void User_Address::set_street(const ::std::string& value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void User_Address::set_street(const char* value) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(value);
}
inline void User_Address::set_street(const char* value, size_t size) {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  street_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User_Address::mutable_street() {
  set_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    street_ = new ::std::string;
  }
  return street_;
}
inline ::std::string* User_Address::release_street() {
  clear_has_street();
  if (street_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = street_;
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User_Address::set_allocated_street(::std::string* street) {
  if (street_ != &::google::protobuf::internal::kEmptyString) {
    delete street_;
  }
  if (street) {
    set_has_street();
    street_ = street;
  } else {
    clear_has_street();
    street_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string postCode = 2;
inline bool User_Address::has_postcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User_Address::set_has_postcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User_Address::clear_has_postcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User_Address::clear_postcode() {
  if (postcode_ != &::google::protobuf::internal::kEmptyString) {
    postcode_->clear();
  }
  clear_has_postcode();
}
inline const ::std::string& User_Address::postcode() const {
  return *postcode_;
}
inline void User_Address::set_postcode(const ::std::string& value) {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void User_Address::set_postcode(const char* value) {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(value);
}
inline void User_Address::set_postcode(const char* value, size_t size) {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  postcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User_Address::mutable_postcode() {
  set_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    postcode_ = new ::std::string;
  }
  return postcode_;
}
inline ::std::string* User_Address::release_postcode() {
  clear_has_postcode();
  if (postcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = postcode_;
    postcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User_Address::set_allocated_postcode(::std::string* postcode) {
  if (postcode_ != &::google::protobuf::internal::kEmptyString) {
    delete postcode_;
  }
  if (postcode) {
    set_has_postcode();
    postcode_ = postcode;
  } else {
    clear_has_postcode();
    postcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 number = 3;
inline bool User_Address::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User_Address::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User_Address::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User_Address::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 User_Address::number() const {
  return number_;
}
inline void User_Address::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// User

// required int32 id = 1;
inline bool User::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 User::id() const {
  return id_;
}
inline void User::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated int32 accountIds = 2;
inline int User::accountids_size() const {
  return accountids_.size();
}
inline void User::clear_accountids() {
  accountids_.Clear();
}
inline ::google::protobuf::int32 User::accountids(int index) const {
  return accountids_.Get(index);
}
inline void User::set_accountids(int index, ::google::protobuf::int32 value) {
  accountids_.Set(index, value);
}
inline void User::add_accountids(::google::protobuf::int32 value) {
  accountids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
User::accountids() const {
  return accountids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
User::mutable_accountids() {
  return &accountids_;
}

// required string name = 3;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& User::name() const {
  return *name_;
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void User::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* User::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string surname = 4;
inline bool User::has_surname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_surname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_surname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_surname() {
  if (surname_ != &::google::protobuf::internal::kEmptyString) {
    surname_->clear();
  }
  clear_has_surname();
}
inline const ::std::string& User::surname() const {
  return *surname_;
}
inline void User::set_surname(const ::std::string& value) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::kEmptyString) {
    surname_ = new ::std::string;
  }
  surname_->assign(value);
}
inline void User::set_surname(const char* value) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::kEmptyString) {
    surname_ = new ::std::string;
  }
  surname_->assign(value);
}
inline void User::set_surname(const char* value, size_t size) {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::kEmptyString) {
    surname_ = new ::std::string;
  }
  surname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_surname() {
  set_has_surname();
  if (surname_ == &::google::protobuf::internal::kEmptyString) {
    surname_ = new ::std::string;
  }
  return surname_;
}
inline ::std::string* User::release_surname() {
  clear_has_surname();
  if (surname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = surname_;
    surname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_surname(::std::string* surname) {
  if (surname_ != &::google::protobuf::internal::kEmptyString) {
    delete surname_;
  }
  if (surname) {
    set_has_surname();
    surname_ = surname;
  } else {
    clear_has_surname();
    surname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .sample_bank_account.User.Address addresses = 5;
inline int User::addresses_size() const {
  return addresses_.size();
}
inline void User::clear_addresses() {
  addresses_.Clear();
}
inline const ::sample_bank_account::User_Address& User::addresses(int index) const {
  return addresses_.Get(index);
}
inline ::sample_bank_account::User_Address* User::mutable_addresses(int index) {
  return addresses_.Mutable(index);
}
inline ::sample_bank_account::User_Address* User::add_addresses() {
  return addresses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User_Address >&
User::addresses() const {
  return addresses_;
}
inline ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User_Address >*
User::mutable_addresses() {
  return &addresses_;
}

// optional int32 age = 6;
inline bool User::has_age() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void User::set_has_age() {
  _has_bits_[0] |= 0x00000020u;
}
inline void User::clear_has_age() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void User::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline ::google::protobuf::int32 User::age() const {
  return age_;
}
inline void User::set_age(::google::protobuf::int32 value) {
  set_has_age();
  age_ = value;
}

// optional .sample_bank_account.User.Gender gender = 7;
inline bool User::has_gender() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void User::set_has_gender() {
  _has_bits_[0] |= 0x00000040u;
}
inline void User::clear_has_gender() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void User::clear_gender() {
  gender_ = 0;
  clear_has_gender();
}
inline ::sample_bank_account::User_Gender User::gender() const {
  return static_cast< ::sample_bank_account::User_Gender >(gender_);
}
inline void User::set_gender(::sample_bank_account::User_Gender value) {
  assert(::sample_bank_account::User_Gender_IsValid(value));
  set_has_gender();
  gender_ = value;
}

// optional string notes = 8;
inline bool User::has_notes() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void User::set_has_notes() {
  _has_bits_[0] |= 0x00000080u;
}
inline void User::clear_has_notes() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void User::clear_notes() {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    notes_->clear();
  }
  clear_has_notes();
}
inline const ::std::string& User::notes() const {
  return *notes_;
}
inline void User::set_notes(const ::std::string& value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void User::set_notes(const char* value) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(value);
}
inline void User::set_notes(const char* value, size_t size) {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  notes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_notes() {
  set_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    notes_ = new ::std::string;
  }
  return notes_;
}
inline ::std::string* User::release_notes() {
  clear_has_notes();
  if (notes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notes_;
    notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void User::set_allocated_notes(::std::string* notes) {
  if (notes_ != &::google::protobuf::internal::kEmptyString) {
    delete notes_;
  }
  if (notes) {
    set_has_notes();
    notes_ = notes;
  } else {
    clear_has_notes();
    notes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Account_Limits

// optional double maxDailyLimit = 1;
inline bool Account_Limits::has_maxdailylimit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account_Limits::set_has_maxdailylimit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account_Limits::clear_has_maxdailylimit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account_Limits::clear_maxdailylimit() {
  maxdailylimit_ = 0;
  clear_has_maxdailylimit();
}
inline double Account_Limits::maxdailylimit() const {
  return maxdailylimit_;
}
inline void Account_Limits::set_maxdailylimit(double value) {
  set_has_maxdailylimit();
  maxdailylimit_ = value;
}

// optional double maxTransactionLimit = 2;
inline bool Account_Limits::has_maxtransactionlimit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account_Limits::set_has_maxtransactionlimit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account_Limits::clear_has_maxtransactionlimit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account_Limits::clear_maxtransactionlimit() {
  maxtransactionlimit_ = 0;
  clear_has_maxtransactionlimit();
}
inline double Account_Limits::maxtransactionlimit() const {
  return maxtransactionlimit_;
}
inline void Account_Limits::set_maxtransactionlimit(double value) {
  set_has_maxtransactionlimit();
  maxtransactionlimit_ = value;
}

// -------------------------------------------------------------------

// Account

// required int32 id = 1;
inline bool Account::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Account::id() const {
  return id_;
}
inline void Account::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string description = 2 [default = "Checking account"];
inline bool Account::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_description() {
  if (description_ != _default_description_) {
    description_->assign(*_default_description_);
  }
  clear_has_description();
}
inline const ::std::string& Account::description() const {
  return *description_;
}
inline void Account::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == _default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Account::set_description(const char* value) {
  set_has_description();
  if (description_ == _default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Account::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == _default_description_) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::mutable_description() {
  set_has_description();
  if (description_ == _default_description_) {
    description_ = new ::std::string(*_default_description_);
  }
  return description_;
}
inline ::std::string* Account::release_description() {
  clear_has_description();
  if (description_ == _default_description_) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(_default_description_);
    return temp;
  }
}
inline void Account::set_allocated_description(::std::string* description) {
  if (description_ != _default_description_) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(_default_description_);
  }
}

// required fixed64 creationDate = 3;
inline bool Account::has_creationdate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_creationdate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_creationdate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_creationdate() {
  creationdate_ = GOOGLE_ULONGLONG(0);
  clear_has_creationdate();
}
inline ::google::protobuf::uint64 Account::creationdate() const {
  return creationdate_;
}
inline void Account::set_creationdate(::google::protobuf::uint64 value) {
  set_has_creationdate();
  creationdate_ = value;
}

// optional .sample_bank_account.Account.Limits limits = 4;
inline bool Account::has_limits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Account::set_has_limits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Account::clear_has_limits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Account::clear_limits() {
  if (limits_ != NULL) limits_->::sample_bank_account::Account_Limits::Clear();
  clear_has_limits();
}
inline const ::sample_bank_account::Account_Limits& Account::limits() const {
  return limits_ != NULL ? *limits_ : *default_instance_->limits_;
}
inline ::sample_bank_account::Account_Limits* Account::mutable_limits() {
  set_has_limits();
  if (limits_ == NULL) limits_ = new ::sample_bank_account::Account_Limits;
  return limits_;
}
inline ::sample_bank_account::Account_Limits* Account::release_limits() {
  clear_has_limits();
  ::sample_bank_account::Account_Limits* temp = limits_;
  limits_ = NULL;
  return temp;
}
inline void Account::set_allocated_limits(::sample_bank_account::Account_Limits* limits) {
  delete limits_;
  limits_ = limits;
  if (limits) {
    set_has_limits();
  } else {
    clear_has_limits();
  }
}

// repeated bytes blurb = 5;
inline int Account::blurb_size() const {
  return blurb_.size();
}
inline void Account::clear_blurb() {
  blurb_.Clear();
}
inline const ::std::string& Account::blurb(int index) const {
  return blurb_.Get(index);
}
inline ::std::string* Account::mutable_blurb(int index) {
  return blurb_.Mutable(index);
}
inline void Account::set_blurb(int index, const ::std::string& value) {
  blurb_.Mutable(index)->assign(value);
}
inline void Account::set_blurb(int index, const char* value) {
  blurb_.Mutable(index)->assign(value);
}
inline void Account::set_blurb(int index, const void* value, size_t size) {
  blurb_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Account::add_blurb() {
  return blurb_.Add();
}
inline void Account::add_blurb(const ::std::string& value) {
  blurb_.Add()->assign(value);
}
inline void Account::add_blurb(const char* value) {
  blurb_.Add()->assign(value);
}
inline void Account::add_blurb(const void* value, size_t size) {
  blurb_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Account::blurb() const {
  return blurb_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Account::mutable_blurb() {
  return &blurb_;
}

// -------------------------------------------------------------------

// Transaction

// required int32 id = 1;
inline bool Transaction::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Transaction::id() const {
  return id_;
}
inline void Transaction::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string description = 2;
inline bool Transaction::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Transaction::description() const {
  return *description_;
}
inline void Transaction::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Transaction::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Transaction::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Transaction::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Transaction::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Transaction::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 accountId = 3;
inline bool Transaction::has_accountid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transaction::set_has_accountid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transaction::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transaction::clear_accountid() {
  accountid_ = 0;
  clear_has_accountid();
}
inline ::google::protobuf::int32 Transaction::accountid() const {
  return accountid_;
}
inline void Transaction::set_accountid(::google::protobuf::int32 value) {
  set_has_accountid();
  accountid_ = value;
}

// required fixed64 date = 4;
inline bool Transaction::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transaction::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transaction::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transaction::clear_date() {
  date_ = GOOGLE_ULONGLONG(0);
  clear_has_date();
}
inline ::google::protobuf::uint64 Transaction::date() const {
  return date_;
}
inline void Transaction::set_date(::google::protobuf::uint64 value) {
  set_has_date();
  date_ = value;
}

// required double amount = 5;
inline bool Transaction::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transaction::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transaction::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transaction::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline double Transaction::amount() const {
  return amount_;
}
inline void Transaction::set_amount(double value) {
  set_has_amount();
  amount_ = value;
}

// required bool isDebit = 6;
inline bool Transaction::has_isdebit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transaction::set_has_isdebit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transaction::clear_has_isdebit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transaction::clear_isdebit() {
  isdebit_ = false;
  clear_has_isdebit();
}
inline bool Transaction::isdebit() const {
  return isdebit_;
}
inline void Transaction::set_isdebit(bool value) {
  set_has_isdebit();
  isdebit_ = value;
}

// required bool isValid = 7;
inline bool Transaction::has_isvalid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Transaction::set_has_isvalid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Transaction::clear_has_isvalid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Transaction::clear_isvalid() {
  isvalid_ = false;
  clear_has_isvalid();
}
inline bool Transaction::isvalid() const {
  return isvalid_;
}
inline void Transaction::set_isvalid(bool value) {
  set_has_isvalid();
  isvalid_ = value;
}

// -------------------------------------------------------------------

// int_array

// repeated int32 theArray = 1;
inline int int_array::thearray_size() const {
  return thearray_.size();
}
inline void int_array::clear_thearray() {
  thearray_.Clear();
}
inline ::google::protobuf::int32 int_array::thearray(int index) const {
  return thearray_.Get(index);
}
inline void int_array::set_thearray(int index, ::google::protobuf::int32 value) {
  thearray_.Set(index, value);
}
inline void int_array::add_thearray(::google::protobuf::int32 value) {
  thearray_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
int_array::thearray() const {
  return thearray_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
int_array::mutable_thearray() {
  return &thearray_;
}

// -------------------------------------------------------------------

// user_list

// repeated .sample_bank_account.User theList = 1;
inline int user_list::thelist_size() const {
  return thelist_.size();
}
inline void user_list::clear_thelist() {
  thelist_.Clear();
}
inline const ::sample_bank_account::User& user_list::thelist(int index) const {
  return thelist_.Get(index);
}
inline ::sample_bank_account::User* user_list::mutable_thelist(int index) {
  return thelist_.Mutable(index);
}
inline ::sample_bank_account::User* user_list::add_thelist() {
  return thelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User >&
user_list::thelist() const {
  return thelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::sample_bank_account::User >*
user_list::mutable_thelist() {
  return &thelist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sample_bank_account

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sample_bank_account::User_Gender>() {
  return ::sample_bank_account::User_Gender_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bank_2eproto__INCLUDED
